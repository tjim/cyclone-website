<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
<link media='all' href='/files/styles.css' rel='stylesheet' type='text/css' />
<link rel="icon" href="/files/cyclone-favicon.png" type="image/png" />
<title>Cyclone: Pointers with Restricted Aliasing</title>
</head>
<body>
</head>
<body>
<div id="header">
  <div id="header_strip">
    <a href="/"><div id="header_logo"></div></a>
  </div>
  <div id="menu">
    <a href="/">Home</a>
    <a href="/blog">Blog</a>
    <a href="/wiki">Wiki</a>
    <a href="/wiki/Download">Download</a>
  </div>
</div>
<div id="content">
<h2>Pointers with Restricted Aliasing</h2>

<h3>Introduction <a name="Introduction"></a></h3>
<p>
The main benefit of the regions described thus far is also their
drawback: to free data you must free an entire region. This implies
that to amortize the cost of creating a region, one needs to allocate
into it many times. Furthermore, the objects allocated in a region
should be mostly in use until the region is freed, or else memory will
be wasted in the region that is unused by the program.</p>

<p>In an attempt to alleviate each of these problems Cyclone provides a
mechanism by which individual objects in a region may be freed prior
to freeing the entire region. Pointers to objects that may be freed
early must obey an aliasing discipline to prevent dangling pointers. A
static analysis ensures that such objects can only ever be accessed
through one pointer at any time. At the time it is freed, this pointer
is invalidated, thus preventing all future accesses to the object.</p>

<p>Pointer types in Cyclone can be qualified by their aliasability. As of
now, there are four alias qualifiers. Each of these qualifiers must
appear as arguments to the <code>@aqual(</code>&#8230;<code>)</code> pointer qualifier mentioned in
section <a href='/wiki/Pointers'>Pointers</a>. The four alias qualifiers are:</p>

<p><strong>Aliasable</strong> Pointer types are by default qualified as
<code>ALIASABLE</code>. These may be freely aliased, but can never be freed. For
instance, <code>int @@aqual(ALIASABLE)</code> is an aliasable non-null pointer to
an <code>int</code>.</p>

<p><strong>Unique</strong> The <code>UNIQUE</code> qualifier on a pointer allows the object pointed
to by that pointer to be deallocated individually, using the function
<code>rufree</code>. For freeing objects to be safe, all accesses to such objects
must be made through a single <code>UNIQUE</code> pointer. That is, only a single
pointer may be used to access the object at any given time; this
trivially guarantees that if the object is freed through its unique
pointer, no other access to the object beyond that point is
possible. Objects that become unreachable but are not freed manually
will be freed by the garbage collector (assuming it&#8217;s not removed with
<code>-nogc</code>). For instance, <code>int ?@aqual(UNIQUE)</code> is a unique fat pointer to
an <code>int</code>.</p>

<p><strong>Reference-counted</strong> The <code>REFCNT</code> qualifier reference-counted qualifier
also permits freeing individual objects. Unlike the <code>UNIQUE</code> qualifier,
multiple pointers to a single object are permitted, the number of
which is tracked dynamically via a hidden reference count stored with
the object. Additional pointers to an object are created explicitly
via a call to <code>alias_refptr</code>, which increases the reference
count. Individual pointers are removed via a call to <code>rdrop_refptr</code>;
when the last pointer is removed (i.e., the reference count is 0), the
object is freed. Like the unique region, objects that become
unreachable will be freed by the garbage collector. For instance, <code>int
*@aqual(REFCNT)</code> is a nullable pointer to a reference counted <code>int</code>.</p>

<p><strong>Restricted</strong> All the alias qualifiers are arranged in a subtyping
hierarchy. The <code>RESTRICTED</code> qualifier is a super-type of all the other
qualifiers. A <code>RESTRICTED</code> pointer may not be freed nor can any aliases
of the pointer be created. For instance, <code>int *@aqual(RESTRICTED)</code> is a
restricted nullable pointer to an <code>int</code>. The subtyping hierarchy is as
below:</p>

<pre><code>               RESTRICTED
               /   |   \
              /    |    \
             /     |     \
     ALIASABLE   UNIQUE   REFCNT
</code></pre>

<h3>Allocation and Freeing <a name="AllocationandFreeing"></a></h3>

<p>Unique and reference-counted pointers can be allocated in any
region. However, to support freeing individual objects from a region
we use a special allocator (see <a href="#ReapAllocatorImplementation">Reap Allocator
Implementation</a>) that maintains
additional metadata. We use the term &#8220;reap&#8221; (= <strong>re</strong>gion + he<strong>ap</strong>) to refer to regions from
which individual objects can be deleted. Any region can contain
objects that can be individually freed. Thus all regions are in fact
reaps.</p>

<p>The allocation mechanism for unique and reference-counted pointers
follows a pattern similar to that used for normal region allocation
described in the previous section. The allocation functions rely on
handles for alias qualifiers which are of type
<code>aqual_t&lt;`q::Q&gt;</code>. Here `q is a type variable of alias qualifier
kind and may be instantiated with the alias qualifiers above. The
Cyclone libraries provide the following global variables:</p>

<pre><code> aqual_t&lt;ALIASABLE&gt; Core::aliasable_qual
 aqual_t&lt;UNIQUE&gt; Core::unique_qual
 aqual_t&lt;REFCNT&gt; Core::refcnt_qual
</code></pre>

<p>which are handles for the aliasable, unique and reference-counted
qualifiers respectively. Note that there is no handle for the
restricted qualifier.</p>

<p>The following expressions are used for allocation:</p>

<ul>
<li><code>qnew(</code><em>aq-identifier</em><code>)</code> <em>expr</em></li>
<li><code>qnew(</code><em>aq-identifier</em><code>)</code> <em>array-initializer</em>  </li>
</ul>

<p>The <code>qnew</code> functions allocate in the `H region, i.e., the heap. They
expect an alias qualifier handle. For instance, to allocate a unique
integer in the heap, one might use</p>

<pre><code>  int @@aqual(UNIQUE) a = qnew(Core::unique_qual) 0;
</code></pre>

<ul>
<li><code>rnew(</code><em>rgn-identifier</em><code>,</code> <em>aq-identifier</em><code>)</code><em>expr</em></li>
<li><code>rnew(</code><em>rgn-identifier</em><code>,</code> <em>aq-identifier</em><code>)</code><em>array-initializer</em>   </li>
</ul>

<p>To allocate an alias-free object in a region other than the heap the
rnew functions can be used. For instance,</p>

<pre><code>  {
    region r;
    int @@aqual(UNIQUE) `r a = rnew(r, Core::unique_qual) 0;
  }
</code></pre>

<p>If <em>aq-identifier</em> is not specified it defaults to the <code>ALIASABLE</code>
handle.</p>

<ul>
<li><code>qmalloc(</code><em>aq-identifier</em><code>,sizeof(</code><em>type</em><code>))</code></li>
<li><code>qcalloc(</code><em>aq-identifier</em><code>,n,sizeof(</code><em>type</em><code>))</code>  </li>
</ul>

<p>Similar to <code>qnew</code> these functions allocate in the heap.  </p>

<ul>
<li><code>rmalloc(</code><em>rgn-identifier</em><code>,</code> <em>aq-identifier</em><code>,sizeof(</code><em>type</em><code>))</code></li>
<li><code>rcalloc(</code><em>rgn-identifier</em><code>,</code> <em>aq-identifier</em><code>,n,sizeof(</code><em>type</em><code>))</code>  </li>
</ul>

<p>Similar to <code>rnew</code> these functions can be used to allocate alias
restricted pointers in the specified region. If <em>aq-identifier</em> is
omitted, it defaults to <code>ALIASABLE</code>.</p>

<p>Since there is no handle for the restricted qualifier, <code>RESTRICTED</code>
qualified pointers cannot be allocated. As with normal region
allocation, we use very simple type inference to ease the burden of
writing qualifiers on types. For instance,</p>

<pre><code>  int *a = rnew(r, Core::unique_qual) 0;
</code></pre>

<p>suffices to allocate a unique integer in the region <code>r</code>.</p>

<p>The Cyclone library provides the following functions to free
alias-free pointers.</p>

<ul>
<li><p><code>Core::ufree(</code><em>ptr</em><code>)</code> To free a heap directed unique pointer <code>ufree</code>
is used.   </p></li>
<li><p><code>Core::rufree(</code><em>rgn-handle</em><code>,</code> <em>ptr</em><code>)</code> To free a unique pointer from a
reap <code>rufree</code> is used. A constraint on the effect qualifiers that
appear on the arguments of this function is described in 
<a href="#SubtypingforEffectQualifierandReaps">Subtyping for Effect Qualifier and
Reaps</a>.</p></li>
<li><p><code>Core::drop_refptr(</code><em>ptr</em><code>)</code> To reduce the reference count on a heap
resident reference counted object <code>drop_refptr</code> is used. The <em>ptr</em>
can no longer be dereferenced following this call. If the
reference count on the object reaches zero then the object is
freed automatically.</p></li>
<li><p><code>Core::rdrop_refptr(</code><em>rgn-handle</em><code>,</code> <em>ptr</em><code>)</code> To reduce the reference
count on a reference counted object in an arbitrary region
<code>rdrop_refptr</code> is used.</p></li>
</ul>

<h3>Unique Pointers <a name="UniquePointers"></a></h3>

<p>To ease programming with unique pointers and allow reuse of library
code, unique pointers can be aliased temporarily within a designated
lexical scope using a special alias pattern. If this kind of aliasing
is not sufficient, users can choose to allocate reference-counted
objects; this idea is explained in the next subsection. We also define
syntax <code>a :=: b</code> to allow two unique pointers <code>a</code> and <code>b</code> to be
atomically swapped. Careful use of the swap operator allows us to
store unique pointers in objects that are not themselves uniquely
pointed to. We also introduce bounded polymorphism over alias
qualifiers and add an additional <em>kind</em> to specify type variables over
these qualifiers. In practice, all of these mechanisms are necessary
for writing useful and reusable code.</p>

<h4>Simple Unique Pointers</h4>

<p>Having a unique pointer ensures the object pointed to is not reachable
by any other means. When pointers are first allocated, e.g., using
<code>malloc</code>, they are unique. Such pointers are allowed to be <em>read
through</em> (that is, dereferenced or indexed) but not copied, as the
following example shows:</p>

<pre><code>  char @fat @aqual(UNIQUE) buf = malloc(3*sizeof(char));
  buf[0] = 'h';
  buf[1] = 'i';
  buf[2] = '\0';
  ...
  ufree(buf);
</code></pre>

<p>This piece of code allocates a unique buffer, and then indexes that
buffer three times to initialize it. Because the process of storing to
the buffer does not copy its unique pointer, it can be safely freed.</p>

<p>When a unique pointer is copied, e.g., when passed as a parameter to a
function or stored in a datastructure, we say it has been
<em>consumed</em>. We ensure that consumed pointers are not read through or
copied via a dataflow analysis. When a consumed pointer is assigned
to, very often it can be <em>unconsumed</em>, making it accessible
again. Here is a simple example that initializes a datastructure with
unique pointers:</p>

<pre><code> 1  struct pair { int *@aqual(UNIQUE) x; int *@aqual(UNIQUE) y; } p;
 2  int *@aqual(UNIQUE) x = new 1;  // initializes x
 3  p.x = x;            // consumes x
 4  x = new 2;          // unconsumes x
 5  p.y = x;            // consumes x
</code></pre>

<p>If an attempt was made to read through or copy x between lines 3 and 4
or after line 5, the flow analysis would reject the code, as in</p>

<pre><code>  int *@aqual(UNIQUE) x = new 1;  // initializes x
  p.x = x;            // consumes x
  p.y = x;            // rejected! x has been consumed already
</code></pre>

<p>When a multi-word data structure is assigned to another one, all of
the unique pointers it contains are consumed. For example:</p>

<pre><code> 1  struct pair { int *@aqual(UNIQUE) x; int *@aqual(UNIQUE) y; } p, q;
 2  p.x = new 1; p.y = new 2;
 3  q = p;              // consumes p.x and p.y
</code></pre>

<p>By default, when a unique pointer is passed to a function, we expect
that the function will not free the pointer, store it in a data
structure, or otherwise make it unavailable to the caller. If a
function violates any of thse assumptions its type must be augmented
with the attribute consume, which indicates that a particular argument
is no longer available to the caller after the call. For example:</p>

<pre><code>void foo(int *@aqual(UNIQUE) x) __attribute__((consume(1))) {
  ufree(x);
}
void bar() {
  int *@aqual(UNIQUE) x = malloc(sizeof(int));
  foo(x);
  *x;//&lt;--- this dereference is not allowed
}
</code></pre>

<p>Here, the <code>consume(1)</code> attribute in the definition of <code>foo</code> indicates that
the first argument is consumed within the function body.</p>

<p>Note that if you fail to free a unique pointer, it will eventually be
garbage collected.</p>

<p>Unique pointers have some restrictions. In particular: </p>

<ul>
<li>No pointer arithmetic is allowed on unique pointers. This ensures
that all unique pointers point to the beginning of the object, so
that the allocator is not confused when a pointer is passed to
ufree.</li>
<li>Take the address of a unique pointer is not allowed. This is
because doing so effectively creates an alias to the original
pointer that cannot be easily tracked statically.</li>
<li>Unique pointers cannot be stored within datatypes (though they can
be stored in tagged unions). This is a shortcoming of the current
flow analysis.</li>
</ul>

<h4>Nested Unique Pointers</h4>

<p>Directly reading a unique pointer is only allowed along a <em>unique
path</em>. A unique path <em>u</em> has the form</p>

<p><em>u</em> ::= <em>x</em> ∣ <em>u</em>.m ∣ <em>u</em>->m ∣ *<em>u</em></p>

<p>where <em>x</em> is a local variable, and <em>u</em> is a unique pointer. To
appreciate the unique-path restriction, consider this incorrect code:</p>

<pre><code>int f(int *@aqual(UNIQUE) *`r x) {
  int *@aqual(UNIQUE) *`r y = x;  //x and y are aliases
  int *@aqual(UNIQUE) z = *y;
  ufree(z);
  return **x;  //accesses deallocated storage!
}
</code></pre>

<p>Here, <code>x</code> is a pointer into a conventional region <code>`r</code> and thus its value
can be freely copied to <code>y</code>. We then extract a unique pointer pointed to
by <code>y</code> and free it. Then we attempt to access the deallocated storage
through <code>x</code>.</p>

<p>If a unique pointer is not accessible via a unique path, it must be
<em>swapped out</em> atomically to be used; in Cyclone this is expressed with
syntax <code>:=:</code>. In particular, the code <code>a :=: b</code> will swap the contents
of <code>a</code> and <code>b</code>. We can use this to swap out a nested unique pointer,
and replace it with a different one; we will often swap in <code>NULL</code>, since
this is a unique pointer that is always unconsumed. For example, in
the code below, we define a queue type for queues that contain unique
pointers, and a function <code>take</code> for removing the first element from the
queue.</p>

<pre><code>struct Queue&lt;`a,`r&gt; { 
  list_t&lt;`a *@aqual(UNIQUE),`r&gt; front; 
  list_t&lt;`a *@aqual(UNIQUE),`r&gt; rear; 
};
typedef struct Queue&lt;`a,`r&gt; *`r queue_t&lt;`a,`r&gt;;

`a *@aqual(UNIQUE) take(queue_t&lt;`a&gt; q) {
  if (q-&gt;front == NULL)
    throw &amp;Empty_val;  // exception: def not shown
  else {
    let elem = NULL;
    elem :=: q-&gt;front-&gt;hd;
    q-&gt;front = q-&gt;front-&gt;tl;
    if (q-&gt;front == NULL) q-&gt;rear = NULL;
    return elem;
  }
}
</code></pre>

<p>Here, in order to extract the element stored in the queue (the <code>hd</code>
portion of the underlying list), we need to use swap, because <code>q-&gt;front</code>
is a non-unique pointer, and therefore <code>q-&gt;front-&gt;hd</code> is not a unique
path.</p>

<p>Note that this code is not as polymorphic as it could be. In
particular, the above queue definition requires its elements to be
nullable unique pointers, when they could just as easily be non-unique
pointers, or even reference-counted pointers (illustrated later), and
the code for <code>take</code> would still work. This problem can be addressed, and
its solution is described in <a href="#QualifierPolymorphism">Qualifier
Polymorphism</a>.</p>

<h4>Pattern Matching on Unique Pointers<a name="Pattern-Matching-on-Unique-Pointers"></a></h4>

<p>As described in <a href='/wiki/Pattern Matching'>Pattern Matching</a>, Cyclone supports pattern
matching on structured data with <code>let</code> declarations and <code>switch</code>
statements. Unique pointers, or structures containing unique pointers,
can be matched against, while still ensuring that only one legal
pointer to a unique object exists at any given time.</p>

<p>In the simplest case, when a unique pointer to a structure is matched
against, the matching operation is treated just like a
dereference. Therefore, the pointer itself is <em>not</em> consumed. For
example:</p>

<pre><code>struct pair { int x; int y; };
void foo() {
  struct pair @@aqual(UNIQUE) p = new pair(1,2);
  let &amp;pair{.x=x, .y=y} = p;
  ufree(p);
}
</code></pre>

<p>Here, we match against the unique pointer <code>p</code>&#8217;s two fields <code>x</code> and
<code>y</code>. Because we don&#8217;t make a copy of <code>p</code>, but rather only of its fields, <code>p</code>
is not consumed. Therefore, <code>p</code> can be safely freed.</p>

<p>Because each of the fields matched against is assigned to the pattern
variables, unique paths through the original pointer are consumed by
virtue of being assigned. At the conclusion of the scope of the
pattern, we can <em>unconsume</em> any location whose pattern variable has
not been consumed or assigned to, as long as the parent pointer has
not been consumed or assigned to. Here&#8217;s an example:</p>

<pre><code>struct Foo { int *@aqual(UNIQUE) x; int *@aqual(UNIQUE) y; };
void foo(struct Foo *@aqual(UNIQUE) p) {
  { let &amp;Foo{.x=x, .y=y} = p; // consumes p-&gt;x and p-&gt;y
    ufree(x);                 // consumes x
  }                           // p-&gt;y is unconsumed
  ufree(p-&gt;y);                // p-&gt;y consumed
  ufree(p);                   // p consumed
}
</code></pre>

<p>The initial match against <code>p</code> consumes <code>p-&gt;x</code> and <code>p-&gt;y</code>, whose contents are
copied to <code>x</code> and <code>y</code>, respectively. At the conclusion of the block, <code>p-&gt;y</code>
is unconsumed because it did not change, whereas <code>p-&gt;x</code> is not, because
<code>x</code> was freed within the block.</p>

<p>Note that the following code is illegal: </p>

<pre><code>void foo(struct Foo *`H p) {
 let &amp;Foo{.x=x, .y=y} = p; // non-unique path!
 ...
}
</code></pre>

<p>To see why, notice that this is equivalent to </p>

<pre><code>void foo(struct Foo *`H p) {
 let x = p-&gt;x;
 let y = p-&gt;y;
 ...
}
</code></pre>

<p>This code is illegal because neither <code>p-&gt;x</code> nor <code>p-&gt;y</code> is a unique
path. We also do not allow <code>*</code> patterns to create aliases of the
original unique pointer, for the same reason we forbid <code>&amp;</code><em>e</em> when <em>e</em>
is a unique pointer. Unfortunately, this means we don&#8217;t provide a way
to assign to matched-against fields. However, in the case of the
matched-against struct, we can just do this with regular paths. In the
above example pattern block, we could do <code>p-&gt;y = new 1</code> or something
like that (even within the scope of the pattern).</p>

<p>Matching against tagged unions is essentially like matching against
structures, as just described. Since we do not allow unique pointers
to be stored within datatypes, there is no change to how datatypes are
matched.</p>

<h3>Reference-counted Pointers <a name="Reference-countedPointers"></a></h3>

<p>Cyclone also supports reference-counted pointers, which are treated
quite similarly to unique pointers. Reference-counted objects may be
allocated in any region. We define the constant <code>Core::refcnt_qual</code>,
having type <code>aqual_t&lt;REFCNT&gt;</code>, for creating reference-counted
pointers. The caveat here is that when you allocate something in this
region, an extra word will be prepended to your data, which contains
the reference count, initialized to 1.</p>

<p>As with unique pointers, no pointer arithmetic is allowed, for similar
reasons: it can occlude where the &#8220;head&#8221; of the object is, and thus
make it impossible to find the hidden reference count. The reference
count can be accessed via the routine <code>Core::refptr_count</code>:</p>

<pre><code>  int refptr_count(`a::TA ?@aqual(REFCNT) ptr);
</code></pre>

<p>The constant <code>NULL</code> is allowed to have type <code>`a::A ?@aqual(REFCNT)</code>, and
its reference count is always 0. Like unique pointers, implicit
aliasing is not allowed. Aliases are created explicitly using the
routine <code>Core::alias_refptr</code>:</p>

<pre><code>  `a ?@aqual(REFCNT) alias_refptr(`a::TA ?@aqual(REFCNT) ptr);
</code></pre>

<p>This routine returns a copy of its argument, which is itself not
consumed. Furthermore, the reference count will be incremented by
one. Reference counts are reduced explicitly by the routine
<code>drop_refptr</code>:</p>

<pre><code>  void drop_refptr(`a::TA ?@aqual(REFCNT) ptr) 
                         __attribute((consume(1)));
</code></pre>

<p>In the case that the provided object&#8217;s reference count is 1 (and is
thus dropped to zero), the provided pointer is freed. The flow
analysis will consume the passed pointer (as is always the case for
function arguments), so you won&#8217;t be able to use it afterwards. Just
like unique pointers, you can &#8220;forget&#8221; reference-counted pointers
without decrementing the count; this just means you&#8217;ll never be able
to free the pointer explicitly, but the GC will get it once it becomes
unreachable.</p>

<p>Just like unique pointers, reference-counted pointers can be stored in
normal, aliasable datastructures, and accessed using swap (e.g. <code>x :=:
y</code>). Because <code>NULL</code> is a <code>`a::TA ?@aqual(REFCNT)</code> pointer, we can always
cheaply construct a pointer to swap in.</p>

<p>A good example of the use of unique pointers and reference-counted
pointers is in the Cyclone distribution&#8217;s <code>tests</code> directory&#8212;the file
<code>streambuff.cyc</code>. This is an implementation of a packet manipulation
library with a representation for packets (called <code>streambuff_t</code>&#8217;s) that
is similar to Linux&#8217;s <code>skbuff_t</code>&#8217;s. It uses a combination of unique
header structures and reference-counted data structures.</p>

<h3>Qualifier Polymorphism <a name="QualifierPolymorphism"></a></h3>

<p>To allow the writing of reusable code we support both subtyping and
bounded polymorphism over alias qualifiers. Type variables that range
over the set of alias qualifiers are of kind <code>Q</code> are used in addition to
the other kinds.</p>

<p>The list data structure in the Cyclone libraries illustrates many
features of qualifier polymorphism. It has the following declaration:</p>

<pre><code>  struct List&lt;`a::B,`r::R,`q::Q&gt;{ 
    : RESTRICTED &gt;= aquals(`a), RESTRICTED &gt;= `q
    `a hd; 
    struct List&lt;`a,`r,`q&gt; *@aqual(`q) `r tl;
  };
  typedef struct List&lt;`a,`r,`q&gt; *@aqual(`q) `r list_t&lt;`a,`r,`q&gt;;
</code></pre>

<p>Here, the structure is parameterized by three type variables. The
first, of boxed-kind, admits instantiation by pointer types. Since
pointer types may be qualified according to their aliasability, we
require a bound on this aliasability. For this purpose, we use the
construct <code>aquals(`a)</code>. Similar to the <code>regions(`a)</code> construct,
<code>aquals(`a)</code>
evaluates to the top-level alias qualifier of the type that
instantiates the variable <code>`a</code>. For instance, <code>aquals(int
*@aqual(ALIASABLE) *@aqual(UNIQUE)) = UNIQUE</code>. The bound in the list
declaration <code>RESTRICTED &gt;= aquals(`a)</code> states that <code>`a</code> can be
instantiated with a boxed kind with an aliasability that is a subtype
of <code>RESTRICTED</code>. Since <code>RESTRICTED</code> is at the top of the subtyping
hierarchy, this is the most general bound on the aliasability of the
type.</p>

<p>The second type variable is of region kind. These types may not be
qualified by aliasability and thus do not appear in the bounds at all.</p>

<p>Finally, we have the type variable <code>`q::Q</code>, of alias qualifier
kind. Thus it can be instantiated with any type that reduces to one of
the alias qualifiers. That is, one of ALIASABLE, UNIQUE, REFCNT,
RESTRICTED or <code>aquals(`a)</code>. The bound on <code>`q</code> also is the most general
bound.</p>

<p>A list that uses unique pointers on the &#8220;spine&#8221; with reference counted
elements might be constructed as follows:</p>

<pre><code>  int *rc_int = qnew(Core::refcnt_qual) 0;
  int *rc_int2 = qnew(Core::refcnt_qual) 1;
  list_t&lt;int*@aqual(REFCNT),`H,UNIQUE&gt; l =
      rnew(Core::heap_region, Core::unique_qual) 
          List{rc_int, 
        rnew(Core::heap_region, Core::unique_qual) 
           List{rc_int2, NULL}};
</code></pre>

<p>We can also quantify over alias qualifiers in function types. For
instance, a function that copies a list can be defined as follows.</p>

<pre><code>list_t&lt;`a,`r,`q&gt; rqcopy(region_t&lt;`r&gt; r,aqual_t&lt;`q&gt; q,
                        list_t&lt;`a,`r2,`p&gt; l
                        : RESTRICTED &gt;= `q,
                          ALIASABLE &gt;= aquals(`a),
                          RESTRICTED &gt;= `p) {
  if(l == NULL)
    return NULL;
  _ tl = NULL;
  tl :=: l-&gt;tl;
  list_t&lt;`a,`r,`q&gt; result = rnew(r,q) List{l-&gt;hd, rqcopy(r,q,tl)};
  l-&gt;tl :=: tl;
  return result;
}
</code></pre>

<p>This function copies a list allocated in a region r2 into a region
r. As previously, the function is polymorphic in both the source and
destination regions. Furthermore, the aliasability of the new list is
specified by the handle q which has type <code>aqual_t&lt;`q&gt;</code>. As previously,
since <code>`q</code> is of alias qualifier kind, a bound can be specified for it &#8212;
this appears after the argument list along with any effects for this
function. Note that the list that is being copied may also have a
spine that is RESTRICTED as specified by the RESTRICTED >= <code>`p</code>
bound. This bound requires that we use the swap operator (:=:) to
ensure that no aliases are manufactured. Finally, since we are copying
the list, the elements of the list itself must be aliasable &#8212; this is
specified by the ALIASABLE >= <code>aquals(`a)</code> bound.</p>

<h3>Aliasing Unique Pointers <a name="AliasingUniquePointers"></a></h3>

<p>Programmers often write code that aliases values temporarily, e.g. by
storing them in loop iterator variables or by passing them to
functions. Such reasonable uses would be severely hampered by &#8220;no
alias&#8221; restrictions on unique pointers. To address this problem, we
introduce a special alias pattern variable that permits temporary
aliasing of a unique pointer. Here is a simple example:</p>

<pre><code>  char *@fat@aqual(UNIQUE) dst, *@fat@aqual(UNIQUE) src = ...
  { let alias &lt;`r&gt;char *@fat`r x = src; // consumes src
    memcpy(dst,x,numelts(x)); }
  // src unconsumed
  ...
  ufree(src);
</code></pre>

<p>In general, an alias pattern has form <code>alias &lt;`r&gt;_t_ x</code>, where <code>`r</code> is a
fresh region variable, and <em>t</em> is the type of x, which may mention
<code>`r</code>. The alias pattern introduces a region <code>`r</code>, copies <code>src</code>
to <code>x</code> which is treated as having the designated type <code>char *@fat`r</code>.
Because <code>`r</code> is non-unique, <code>x</code> can be freely aliased. As such, we can
pass <code>x</code> to the <code>memcpy</code> function. The matching operation consumes <code>src</code>
during the block, and unconsumes it upon exit, so that <code>src</code> can be
ultimately freed.</p>

<p>Alias pattern variables are similar to regular pattern variables. Like
regular pattern variables, the matched-against expression (i.e. src in
the above example) must be a unique path, and is consumed as a result
of the match. As well, this expression can be unconsumed at the
conclusion of the surrounding block as long as it hasn&#8217;t been
overwritten. However, in the case of regular pattern variables,
unconsumption also requires that the pattern variable itself (i.e. <code>x</code>
in the above example) hasn&#8217;t changed within the block, while this
requirement is unnecessary for alias patterns.</p>

<p>Intuitively, alias pattern variables are sound because we cast a
unique pointer to instead point into a fresh region, for which there
is no possibility of either creating new values or storing existing
values into escaping data structures. As such we cannot create aliases
that persist beyond the surrounding scope. However, we must take care
when aliasing data having recursive type. For example, the following
code is unsound:</p>

<pre><code>  void foo(list_t&lt;`a, `r1, UNIQUE&gt; l) {
    let alias &lt;`r&gt; x = (list_t&lt;`a, `r1, UNIQUE&gt;)l;
    x-&gt;tl = x; // unsound: creates alias!
  }
</code></pre>

<p>In this case, the alias effectively created many values in the fresh
region <code>`r</code>: one for each element of the list. This allows storing an
alias in an element reachable from the original expression l, so that
when the block is exited, this alias escapes.</p>

<p>For improved programmer convenience, the Cyclone typechecker
optimistically inserts alias blocks around function-call arguments
that are unique pointers when the formal-parameter type is polymorphic
in the pointer&#8217;s region. If this modified call does not type-check, we
remove the inserted alias. For example, the alias pattern in the foo
function above could be inferred, so we could instead write:</p>

<pre><code>  int foo() {
    list_t&lt;int,`H,UNIQUE&gt; l = new List(1,new List(2,NULL));
    return length(l);
  }
</code></pre>

<p>Right now, alias inference in Cyclone is fairly primitive, but could
be extended to more contexts. We plan to improve this feature in
future releases.</p>

<h3>Dynamic Regions <a name="DynamicRegions"></a></h3>

<p>Dynamic regions combine reference-counted or unique pointers and
lexical regions together to essentially create reference-counted or
unique <em>regions</em>; that is, the region is completely first class, and
can be created or freed at conceptually any program point. This is
done by representing a dynamic region as a unique (or
reference-counted) pointer to an abstract struct <code>DynamicRegion</code> (which
internally just contains the handle to a lexical region). The unique
(or ref-counted) pointer is called the <em>key</em>. The key serves as a
run-time <em>capability</em> that grants access to the region. At run-time, a
key can be presented to a special <code>open</code> primitive, described later,
that grants lexical access to the region.</p>

<p>The operation <code>new_ukey()</code> creates a fresh dynamic region and returns a
unique key for the region; <code>new_rckey()</code> creates a fresh dynamic region
and returns a ref-counted key for the region. The operations
<code>free_ukey()</code> and <code>free_rckey()</code> are used to destroy unique and
ref-counted keys respectively. The <code>free_ukey()</code> operation reclaims the
key&#8217;s region, as well as the storage for the key. The <code>free_rckey()</code>
operation decrements the reference count, and if it&#8217;s zero, reclaims
the key&#8217;s region as well as the storage for the key. Because
ref-counted keys are pointers, you can use <code>alias_refptr</code> to make a copy
of a ref-counted key. (Obviously, you can&#8217;t make a copy of a unique
key.) By the same token, you can pass a ref-counted key to <code>drop_refptr</code>
(and you can pass a unique key to <code>ufree</code>), but doing so won&#8217;t actually
deallocate the region, but rather only the key. To obtain a dynamic
<em>reap</em> (i.e. a dynamic region that supports the deletion of individual
objects) use <code>new_reap_ukey</code> and <code>new_reap_rckey</code> instead.</p>

<p>Given a key <em>k</em>, a user can access the contents of its region by
temporarily &#8220;opening the region&#8221; within a lexical scope. This is done
with the syntax <code>region</code> <em>r</em> <code>= open</code> <em>k</em>. That is, within the
remainder of the current scope, the region handle <em>r</em> can be used to
access <em>k</em>&#8217;s region. The key <em>k</em> is temporarily consumed throughout
the scope, and then unconsumed at its conclusion. This prevents you
from opening up the dynamic region, and then freeing it while it&#8217;s
still in use. Note that open is very similar to alias in this way.</p>

<p>Here is a small example of the use of dynamic regions. </p>

<pre><code>int main() {
  // Create a new dynamic region
  let NewDynamicRegion{&lt;`r&gt; key} = new_ukey();

  // At this point, we refer to the region `r to
  // specify types, but we cannot actually access
  // `r (i.e. it's not in our "static capability,"
  // a concept explained later)

  list_t&lt;int,`r&gt; x = NULL;

  // We can access x by opening the region, which
  // temporarily consumes the key
  { region h = open(key);
    x = rnew(h) List(3,x);
  }

  // Now we can access the key again, but not x.
  // So we have to open the region to increment
  // its contents
  { region h = open(key);
    int i = x-&gt;hd + 1;
    x = rnew (h) List(i,x);
  }

  // Finally, destroy the key and the region
  free_ukey(key);
}
</code></pre>

<p>First, we allocate a new unique key and open it up, to reveal the name
of the key&#8217;s region (<code>`r</code>), and the key itself. Because <code>`r</code> is now in
scope, we can declare a variable <code>x</code> that refers to it. However, because
the key key must be opened before <code>`r</code> becomes accessible, we cannot
actually do anything with <code>x</code> yet (like dereference it).</p>

<p>Next, we open up the region using <code>key</code>, assigning its handle to the
vairable <code>h</code>. Now, <code>key</code> is inaccessible (consumed) in the surrounding
block, which prevents us from doing anything that might cause it to be
freed while it&#8217;s in use. We can use <code>h</code> to allocate into <code>`r</code>, so we
allocate a list element and store it in <code>x</code>.</p>

<p>At the conclusion of the block, the region <code>`r</code> becomes inaccessible
again, so once again we cannot dereference <code>x</code>. However, <code>key</code> can now be
accessed again, so we can open it again in the following block, to add
a new list cell to <code>x</code>. At the conclusion of this block, <code>key</code> is
unconsumed once again, so we legally call <code>free_ukey</code>. This frees the
key and the region <code>`r</code>.</p>

<p>You can &#8220;share&#8221; a dynamic region key by placing it in some shared data
structure, like a global variable. Of course, you&#8217;ll then have to swap
with NULL to get it in and out of the shared data structure, as the
following code demonstrates:</p>

<pre><code>struct MyContainer { &lt;`r&gt;
  uregion_key_t&lt;`r&gt; key;
  list_t&lt;int,`r&gt; data;
} *\U `H global = NULL;

int main() {
  // allocate a dynamic region, and create a list
  let NewDynamicRegion{&lt;`r&gt; key} = new_ukey();
  list_t&lt;int,`r&gt; x = NULL;
  { region h = open(key);
    x = rnew(h) List(3,x);
  }

  // Stick the key and list in a global data
  // structure. We've now lost direct access to
  // the key and x.
  global = new MyContainer{key,x};

  // But we can regain it by swapping for the
  // container.
  struct MyContainer *@aqual(UNIQUE) p = NULL;
  global :=: p;

  // Now we can use it as above
  let MyContainer{&lt;`r2&gt; key2, data2} = *p;
  list_t&lt;int,`r2&gt; d = data2;
  { region h = open(key2);
    int i = d-&gt;hd + 1;
    d = rnew (h) List(i,d);
  }
}
</code></pre>

<p>Here, we define a global variable having type MyContainer, which
consists of a key and some data into that key&#8217;s region. The main
function allocates a unique as before, and allocates some data into
its region. Then we create a container for that key and data, and
store it into the global variable; this consumes key, making it
inaccessible, and effectively preventing access of x as well.</p>

<p>But we can then get the container back out of the global variable by
swapping its contents with NULL. Then we can open up the container,
and use the key and data as before. This way, a single dynamic region
can be used by many different functions in the program. They simply
swap out the global when they need it, operate on it, and then swap in
the result.</p>

<p>One problem with using this technique with unique keys arises when you
need to open the same region multiple times. The problem, of course,
is that if you swap in NULL, then whoever tries to swap it out will
fail. In other words, you can&#8217;t really do recursive opens with UNIQUE
keys. However, you can do this with REFCNT keys! Swap out the key,
make a copy of it, swap it back in, and use the copy for the open
(making sure to destroy the copy after the open).</p>

<p>One disadvantage of dynamic regions, which is inherited from unique
and reference-counted pointers, is that if you put a key in some
shared storage in a region <code>r, then it is not the case that when</code>r is
deallocated that the key will be destroyed automatically. It&#8217;s up to
you to do the right thing or let the GC eventually collect it. In the
long run, the right thing to do is add a finalizer interface for
regions so that we can register a routine to deallocate a dynamic
region whenever we put it in a shared data structure. The same goes
for any unique pointer &#8211; we ought to have a way to register a
finalizer. This is on our To-do list.</p>

<h3>Defaults and Shorthands <a name="DefaultsandShorthands"></a></h3>

<p>As described so far, the notation for alias qualifiers is extremely
verbose. The default qualifier annotations and bounds are intended to
capture the most common cases and reduce the burden on the
programmer. Where the defaults do not suffice, shorthand versions
allow explicit types to specified in a more compact manner.</p>

<p>The shorthand notation is as follows: </p>

<p><strong>Alias Qualifier Specifier</strong> The strings <code>\A, \U, \RC, \T</code> can be
used as substitutes for <code>@aqual(ALIASABLE)</code>, <code>@aqual(UNIQUE)</code>,
<code>@aqual(REFCNT)</code>, and <code>@aqual(RESTRICTED)</code> respectively. For example</p>

<pre><code>    void cons(int *\T a, int *\U b)
</code></pre>

<p>is equivalent to </p>

<pre><code>    void cmp(int *@aqual(RESTRICTED) a, int *@aqual(UNIQUE) b)
</code></pre>

<p><strong>Type Variable Bound</strong> The bound on a type variable, as shown
previously, generally appears together with the effects in a function
type, or with the outlives relations for an aggregate type. However,
when the strings <code>\A, \U, \RC, \T</code> succeed a type variable they are
interpreted as a bound on the type variable. This bound is only legal
within an struct declaration or a function type, i.e., bounds may not
appear within a local variable declaration, typedefs etc. If the type
variable is of alias qualifier kind (kind Q) then this is interpreted
as a qualifier bound. If the variable is of boxed, memory or abstract
kind (::B, ::M, or ::A) then it is interpreted as an aquals bound. For
instance, the function rqcopy above can be written as</p>

<pre><code>  list_t&lt;`a,`r,`q&gt; rqcopy(region_t&lt;`r&gt; r,aqual_t&lt;`q\T&gt; q,
                          list_t&lt;`a\A,`r2,`p\T&gt; l);
</code></pre>

<p>The same convention applies to aggregate types. For instance, we could
define List as follows</p>

<pre><code>  struct List&lt;`a::B\T,`r::R,`q::Q\T&gt;{ 
    `a hd; 
    struct List&lt;`a,`r,`q&gt; *@aqual(`q) `r tl;
  };
</code></pre>

<p>Note that if a type variable is used to specify the alias qualifier on
a pointer, then the @aqual(.) notation must be used. That is,
<code>int *@aqual(`q\T)</code> cannot be substituted with <code>int *`q\T</code>.</p>

<p><strong>Heap Pointers</strong> For unique and reference counted pointers that
reside in the heap we overload the region notation to provide a
further shorthand. This is also for backward compatibility with
previous versions of Cyclone where unique and reference counted
pointers always resided in a separate region. Thus the type
<code>T *@aqual(\U) `H</code> can be written more compactly as <code>T *`U</code>; the
type <code>T *@aqual(\RC) `H</code> can be written as <code>T *`RC</code>. The default
qualifier bounds are as follows:</p>

<p><strong>Function Types</strong> The aliasability of all parameters and return types
in a function type is ALIASABLE by default. If a formal parameter is
declared as <code>T *@aqual(\T)</code> then all subtypes of T
*@aqual(RESTRICTED) may be passed as an argument. For parametricity
<code>T *@aqual(`q\T)</code> should be used instead.</p>

<p><strong>Struct Types</strong> For pointers within a struct the default aliasability
is ALIASABLE. For qualifier variables `q::Q the default bound is
RESTRICTED. The aquals bounds for type variables is RESTRICTED by
default. Thus the following declarations are equivalent</p>

<pre><code>    struct PtrList&lt;`a::A, `q&gt; {
      `a *hd; 
      struct PtrList&lt;`a,`q&gt; *@aqual(`q) tl;
    };

    struct PtrList&lt;`a::A\T,`q\T&gt; { 
      `a *@aqual(\A) hd; 
      struct PtrList&lt;`a,`q&gt; *@aqual(`q) tl;
    };
</code></pre>

<p><strong>Type Instantiations</strong> When a type variable is instantiated with a
pointer type we have to decide the aliasability of pointer. When
instantiated in a function type or an aggregate type the aliasability
is by default ALIASABLE. For instance, the following are equivalent:</p>

<pre><code>    void int_list(list_t&lt;int*&gt; l);
    void int_list(list_t&lt;int *@aqual(\A)&gt; l);

    struct Wrapper {
      list_t&lt;int*&gt; l;
    }
    struct Wrapper {
      list_t&lt;int*@aqual(ALIASABLE)&gt; l;
    }
</code></pre>

<p>In variable declarations the default is RESTRICTED to allow for more
aggressive unification. For instance</p>

<pre><code>    void int_list(list_t&lt;int*@aqual(\T)&gt; l) {
      list_t&lt;int*&gt; cp = l;
    }
</code></pre>

<p>In the local variable declaration the bound defaults to RESTRICTED so
that unification with the formal succeeds.</p>

<h3>Subtyping for Effect Qualifier and Reaps <a name="SubtypingforEffectQualifierandReaps"></a></h3>

<p>We mentioned in <a href="#AllocationandFreeing">Allocation and Freeing</a> that
there was more to the type of Core::rufree. The full type of the
function is given below.</p>

<pre><code> void rufree(region_t&lt;`r&gt; h, `a::A\T *\U `r ptr 
             : single(`r))  __attribute__((noliveunique(2)));
</code></pre>

<p>This type states that <code>rufree</code> expects a handle into region <code>`r</code> as its
first argument. The <code>`r</code> effect qualifier on the second argument is
meant to indicate that ptr is a pointer into the region <code>`r</code>, the handle
of which is the first argument. The <code>\U</code> qualifier indicates that ptr
must be a <em>unique</em> pointer into that region. The type of the element
that is pointed to by ptr can be anything at all (<code>`a::A</code>), and may
itself contain unique or reference-counted pointers, as indicated by
the qualifier bound <code>\T</code>.</p>

<p>The attribute <code>noliveunique</code> that appears in the type is a variant of
the <code>consume</code> attribute shown earlier. This attribute states that
after the call to the rufree, the pointer passed as the second
parameter is consumed. Furthermore, if the element pointed to by ptr
contains a live unique pointer, then Cyclone issues a warning. The
reason is that since ptr is the only pointer to the underlying
element, if this element contains a unique or reference-counted
pointer, then the last reference to those pointers are lost leading to
a memory leak.</p>

<p>The last component of the type of rufree is the <code>single(`r)</code>
constraint. The effect qualifier annotation of <code>`r</code> on both the
handle as well as the pointer is meant to force the pointer to point
into the region of the provided handle. However, in the presence of
subtyping over effect qualifiers (as described in 
<a href='http://localhost:8080/wiki/The%20Truth%20About%20Effects,%20Capabilities%20and%20Effect%20Subset%20Constraints/'>The Truth About Effects, Capabilities and Effect Subset Constraints</a>) the annotations on the parameters alone
don&#8217;t suffice to enforce this invariant. This is illustrated by
the example below.</p>

<pre><code>void bad_rufree(region_t&lt;`r&gt;, `a *\U `r); 
void foo() {
  region r;
  int *`r ptr = rnew(r) 1;
  region_t&lt;`r+`H&gt; a = Core::heap_region;
  bad_rufree(a, ptr);
}
</code></pre>

<p>Subtyping of effect qualifiers means that it is permissble to treat
<code>int *`r</code> as <code>int*`r+`H</code> and so the call to <code>bad_rufree</code>
typechecks even though pointer ptr does not point into the region for
which a is the handle.</p>

<p>To avoid this behavior, the <code>single(`r)</code> constraint is used to limit
subtyping on the effect qualifier variable <code>`r.</code> In particular, an
effect qualifier variable that appears in a <code>single(`r)</code> constraint
is guaranteed to always be instantiated with a <em>single</em> region name,
and not a set of region names.</p>

<h3>Reap Allocator Implementation <a name="ReapAllocatorImplementation"></a></h3>

<p>To support deallocation of objects within a region the allocator must
maintain some meta-data associated with each object. The current
implementation uses a version of the bget allocator adapted for use
with reaps. When deallocation is rare, bget behaves much like a simple
pointer bumping allocator and we expect performance to be
competitive. However, the metadata does consume two additional header
words for each object allocated.</p>

<p>For normal regions (i.e. those declared as region r, or those created
using <code>new_ukey</code>, or <code>new_rckey</code>) the simple pointer-bumping allocator
is used. Thus, if your application does not use reaps at all, then the
overhead due to bget therefore does not apply.</p>
</div>
</body>
</html>
